/* tslint:disable */
/* eslint-disable */
/**
 * Aeternity Middleware
 * API for [Aeternity Middleware](https://github.com/aeternity/ae_mdw)
 *
 * The version of the OpenAPI document: 1.51.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * Balance currently left in the channel
     * @type {number}
     * @memberof Channel
     */
    amount?: number;
    /**
     * Channel pubkey
     * @type {string}
     * @memberof Channel
     */
    channel?: string;
    /**
     * Minimum amount for sufficient funds
     * @type {number}
     * @memberof Channel
     */
    channelReserve?: number;
    /**
     * Pubkeys of delegated accounts
     * @type {object}
     * @memberof Channel
     */
    delegateIds?: object;
    /**
     * Channel initiator pubkey
     * @type {string}
     * @memberof Channel
     */
    initiator?: string;
    /**
     * Amount owned by initiator
     * @type {number}
     * @memberof Channel
     */
    initiatorAmount?: number;
    /**
     * The last height in which the channel was updated
     * @type {string}
     * @memberof Channel
     */
    lastUpdatedHeight?: string;
    /**
     * The transaction type of the last transaction that updated the channel
     * @type {string}
     * @memberof Channel
     */
    lastUpdatedTxType?: string;
    /**
     * Amount of heights locked after a solo closing
     * @type {number}
     * @memberof Channel
     */
    lockPeriod?: number;
    /**
     * Non-inclusive height until which the channel is locked
     * @type {number}
     * @memberof Channel
     */
    lockedUntil?: number;
    /**
     * The channel responder pubkey
     * @type {string}
     * @memberof Channel
     */
    responder?: string;
    /**
     * Amount owned by responder
     * @type {number}
     * @memberof Channel
     */
    responderAmount?: number;
    /**
     * Round after last transaction
     * @type {number}
     * @memberof Channel
     */
    round?: number;
    /**
     * Round of last solo transaction
     * @type {number}
     * @memberof Channel
     */
    soloRound?: number;
    /**
     * The hash of the current channel state
     * @type {string}
     * @memberof Channel
     */
    stateHash?: string;
    /**
     * The amount of times the channel's been updated by any of the channel transactions
     * @type {string}
     * @memberof Channel
     */
    updatesCount?: string;
}

/**
 * Check if a given object implements the Channel interface.
 */
export function instanceOfChannel(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function ChannelFromJSON(json: any): Channel {
    return ChannelFromJSONTyped(json, false);
}

export function ChannelFromJSONTyped(json: any, ignoreDiscriminator: boolean): Channel {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'amount': !exists(json, 'amount') ? undefined : json['amount'],
        'channel': !exists(json, 'channel') ? undefined : json['channel'],
        'channelReserve': !exists(json, 'channel_reserve') ? undefined : json['channel_reserve'],
        'delegateIds': !exists(json, 'delegate_ids') ? undefined : json['delegate_ids'],
        'initiator': !exists(json, 'initiator') ? undefined : json['initiator'],
        'initiatorAmount': !exists(json, 'initiator_amount') ? undefined : json['initiator_amount'],
        'lastUpdatedHeight': !exists(json, 'last_updated_height') ? undefined : json['last_updated_height'],
        'lastUpdatedTxType': !exists(json, 'last_updated_tx_type') ? undefined : json['last_updated_tx_type'],
        'lockPeriod': !exists(json, 'lock_period') ? undefined : json['lock_period'],
        'lockedUntil': !exists(json, 'locked_until') ? undefined : json['locked_until'],
        'responder': !exists(json, 'responder') ? undefined : json['responder'],
        'responderAmount': !exists(json, 'responder_amount') ? undefined : json['responder_amount'],
        'round': !exists(json, 'round') ? undefined : json['round'],
        'soloRound': !exists(json, 'solo_round') ? undefined : json['solo_round'],
        'stateHash': !exists(json, 'state_hash') ? undefined : json['state_hash'],
        'updatesCount': !exists(json, 'updates_count') ? undefined : json['updates_count'],
    };
}

export function ChannelToJSON(value?: Channel | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'amount': value.amount,
        'channel': value.channel,
        'channel_reserve': value.channelReserve,
        'delegate_ids': value.delegateIds,
        'initiator': value.initiator,
        'initiator_amount': value.initiatorAmount,
        'last_updated_height': value.lastUpdatedHeight,
        'last_updated_tx_type': value.lastUpdatedTxType,
        'lock_period': value.lockPeriod,
        'locked_until': value.lockedUntil,
        'responder': value.responder,
        'responder_amount': value.responderAmount,
        'round': value.round,
        'solo_round': value.soloRound,
        'state_hash': value.stateHash,
        'updates_count': value.updatesCount,
    };
}

